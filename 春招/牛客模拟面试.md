2.11

# 1.请问怎么判断哪些对象是可以删除的，可达是什么意思

既然java都是通过JVM来管理内存，那么怎么判定一个对象是否要被垃圾回收呢。
简单来说，判定一个对象是否要被回收有俩个方法：
引用计数法和可达性分析法。

## 1.引用计数法

### **在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器的值+1，当引用失效的时候，计数器的值-1**

虽然简单高效
但是，在主流的 Java 虚拟机中并没有选用引用技术算法来管理内存，

**在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收**。

正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法 

可能会存在不再使用但又不能回收的内存，造成内存泄漏

## 2.可达性算法

### 以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。Java 虚拟机使用该算法来判断对象是否可被回收

#### GC Roots 包括；

1.  **全局性引用**，对方法区的静态对象、常量对象的引用

2.  执行上下文，对 **Java 方法栈帧中的局部对象引用**、对 JNI handles 对象引用

3.  **已启动且未停止的 Java 线程**

   **两大问题**

   1. **误报**：已死亡对象被标记为存活，垃圾收集不到。多占用一会内存，影响较小。
   2. **漏报**：引用的对象（正在使用的）没有被标记为存活，被垃圾回收了。那么直接导
   致的就是 JVM 奔溃。（STW 可以确保可达性分析法的准确性，避免漏报）





# 2.请问，redis为什么是单线程？

官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis利用队列技术将并发访问变为串行访问

 1）绝大部分请求是纯粹的内存操作（非常快速）

2）采用单线程,避免了不必要的上下文切换和 不需要各种锁的性能消耗

3）非阻塞IO优点：

redis是一种纯内存计算并且支持数据持久化的NoSQL数据库，单线程可以避免线程之间的上下文切换。

redis的线程模型为多路IO复用机制，再加上其自建的内存管理系统和简单的数据结构，所以单线程的redis的速度已经足够快，其性能瓶颈主要体现在网络上。

