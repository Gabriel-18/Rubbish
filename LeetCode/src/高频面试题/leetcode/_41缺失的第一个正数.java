package 高频面试题.leetcode;

public class _41缺失的第一个正数 {
    public int firstMissingPositive(int[] nums) {
        int len = nums.length;
        for (int i = 0; i < len; ++i) {
            //这里用while是因为交换回来的值不一定是"值配其位"的，那么就可能还需要进行交换
            //比如[4,1,2,3]
            // 1.第一次将4与3交换，形成[3,1,2,4]，明显3是"值不配位"的，也满足条件，进入新的交换
            // 2.第二次将3与2交换，形成[2,1,3,4]，明显2也是"值不配位"的，且满足条件，进入新的交换
            // 3.第三次将2与1交换，形成[1,2,3,4]，值全都配位了，后面的while也就都不会进了
            // (此处也说明while循环不会每一次都把数组里面的所有元素都看一遍。如果有一些元素在这一次的循环中
            // 被交换到了它们应该在的位置，那么在后续的遍历中，由于它们已经在正确的位置上了，代码再执行到它们
            // 的时候，就会被跳过。----引用自@liweiwei1419的题解)
            //**所以此处不能用if**
            while (nums[i] > 0 && nums[i] <= len && nums[nums[i] - 1] != nums[i]) {
                //将出现的值都交换到相应的位置上，组成一个近似排序的数组
                //其中的负数和大于数组长度的值都可以不用管，因为它是作为一个出口存在的
                //这里值1放在索引0上，即值(i)需要放在索引(i-1)上
                int temp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }
        for (int i = 0; i < len; ++i) {
            //第一个不满足 值(nums[i])=索引(i+1) 的值所在索引(i)+1即最小未出现的正整数
            //注意：以下的例子都是经过换位之后
            //例1：[1,2,3,4] 这个例子是完全排序的数组，且每个位置都正确，那么就应该返回数组长度+1，而不是3+1
            //例2：[1,-1,3,4] 其中-1是第一个也是唯一一个"值不配位"的值，那么它所占的位置就是未出现的最小正整数
            //例3：[5,11,7,9] 这个例子是完全没有进入while排序的，因为他们所有的值都"值不配位"，那么同上面的例2，
            // 第一个"值不配位"的值所占的位置就是未出现的最小正整数
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        // 都正确则返回数组长度 + 1
        return len + 1;
    }
}
