package 高频面试题.leetcode;

/***
 但其本质是本题求的是排列总和，而且仅仅是求排列总和的个数，并不是把所有的排列都列出来。

 如果本题要把排列都列出来的话，只能使用回溯算法爆搜。

 动规五部曲分析如下：

 确定dp数组以及下标的含义
 dp[i]: 凑成目标正整数为i的排列个数为dp[i]

 确定递推公式
 dp[i]（考虑nums[j]）可以由 dp[i - nums[j]]（不考虑nums[j]） 推导出来。

 因为只要得到nums[j]，排列个数dp[i - nums[j]]，就是dp[i]的一部分。

 在动态规划：494.目标和 和 动态规划：518.零钱兑换II中我们已经讲过了，求装满背包有几种方法，递推公式一般都是dp[i] += dp[i - nums[j]];

 本题也一样。

 dp数组如何初始化
 因为递推公式dp[i] += dp[i - nums[j]]的缘故，dp[0]要初始化为1，这样递归其他dp[i]的时候才会有数值基础。

 至于dp[0] = 1 有没有意义呢？

 其实没有意义，所以我也不去强行解释它的意义了，因为题目中也说了：给定目标值是正整数！ 所以dp[0] = 1是没有意义的，仅仅是为了推导递推公式。

 至于非0下标的dp[i]应该初始为多少呢？

 初始化为0，这样才不会影响dp[i]累加所有的dp[i - nums[j]]。

 PS：相信很多小伙伴刷题的时候面对力扣上近两千道题目，感觉无从下手，我花费半年时间整理了Github项目：leetcode刷题攻略。 里面有100多道经典算法题目刷题顺序、配有40w字的详细图解，常用算法模板总结，以及难点视频讲解，按照list一道一道刷就可以了！star支持一波吧！

 确定遍历顺序
 个数可以不限使用，说明这是一个完全背包。

 得到的集合是排列，说明需要考虑元素之间的顺序。

 本题要求的是排列，那么这个for循环嵌套的顺序可以有说法了。

 在动态规划：518.零钱兑换II 中就已经讲过了。

 如果求组合数就是外层for循环遍历物品，内层for遍历背包。

 如果求排列数就是外层for遍历背包，内层for循环遍历物品。

 如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举一个例子：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！

 所以本题遍历顺序最终遍历顺序：target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历。

 */
public class _377组合总和Ⅳ {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for (int i = 0; i <= target; i++) { // 遍历背包
            for (int j = 0; j < nums.length; j++) { // 遍历物品
                if (i >= nums[j] ) {
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
}
